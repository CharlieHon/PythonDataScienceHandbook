# IPython：超越Python

## 1.8 错误和调试

### 1.8.1 控制异常: %xmode

大多数时候，当一个Python脚本未执行通过时，会抛出一个异常。当解释器捕获到这些异常时，可以在**轨迹追溯**(traceback)中找到引起这个错误的原因。利用`%xmode`魔法函数，IPython允许你**在异常发生时控制打印信息的数量**。

`%xmode`有一个输入参数，即**模式**。模式有3个可选项：`Plain`, `Context`和`Verbose`。默认情况是 Context。`Plain`更紧凑，给出的信息更少。`Verbose`模式加入了一些额外的信息，包括任何被调用的函数的参数。

|    异常模式                 | 控制异常 |
| ------------------- | -------- |
| `Context`(默认情况) |  ![Context](https://pic4.zhimg.com/80/v2-e436051718a2f95f38d93522d18c3cc5.png)        |
| `Verbose`           |   ![Verbose](https://pic4.zhimg.com/80/v2-b64dcf45a31c168ee964628d91a4bc99.png)       |
| `Plain`                    |  ![Plain](https://pic4.zhimg.com/80/v2-85e998b09772b6eb9fba7a95ce3c0941.png)        |

### 1.8.2. 调试：当阅读轨迹追溯不足以解决问题时

标准的Python交互式调试工具是`pdb`，它是Python的调试器。这个调试器允许用户逐行运行代码，以便查看可能导致错误的原因。IPython增强版的调试器是`ipdb`，它是IPython专用的调试器。

IPython中最方便的调试界面是`%debug`魔法命令。**在捕获异常后调用该调试器，会在异常点自动打开一个交互式调试提示符**。`ipdb`提示符允许探索栈空间的当前状态，探索可用变量，甚至运行Python命令！输入`q(uit)`可以结束调试会话。

![%debug](https://pic4.zhimg.com/80/v2-768333cf4d68902eeae9bc7a6be203f2.png)

可以设置单步入栈和出栈来查看变量的值：

![%debug](https://pic4.zhimg.com/80/v2-7b30e3ebe3560f832586de5f66b4b675.png)

这样可以快速找到导致错误的原因，并且指导是哪一个函数调用导致了错误。
如果希望在发生错误时都自动启动调试器，可以用`%pdb`魔法函数来启动这个自动过程：

![%pdb](https://pic4.zhimg.com/80/v2-b46bac5955ce3d3717d6ce89be23a88a.png)

- **部分调试命令**

以下列举了一部分可用的交互式调试命令及其描述。

| 命令         | 描述                                   |
| ------------ | -------------------------------------- |
| `list`       | 显示文件的当前路径                     |
| `h(help)`    | 显示命令列表，或查找特定命令的帮助信息 |
| `q(uit)`     | 退出调试器和程序                       |
| `c(ontinue)` | 退出调试器，继续运行程序               |
| `n(ext)`     | 调到程序的下一步                       |
| `<enter>`    | 重复前一个命令                         |
| `p(rint)`    | 打印变量                               |
| `s(tep)`     | 步入子进程                             |
| `r(eturn)`   | 从子进程跳出                                       |

在调试器中使用`help`命令，或查看[`ipdb`的在线文档](https://github.com/gotcha/ipdb)获取更多的相关信息。

## 1.9 代码的分析和计时

代码运行后，提高代码的运行效率总是有用的。有时候查看给定命令或一组命令的运行时间非常有用，有时候深入多行进程并确定一系列复杂操作的效率瓶颈也非常有用。IPython提供了很多**执行这些代码计时和分析的操作函数**。

| IPython魔法命令 | 功能                                             |
| --------------- | ------------------------------------------------ |
| `%time`         | 对单个语句的执行时间进行计时                     |
| `%timeit`       | 对单个语句的重复执行进行计时，以获得更高的准确度 |
| `%prun`         | 利用分析器运行代码                               |
| `%lprun`        | 利用逐行分析器运行代码                           |
| `%memit`        | 测量单个语句的内存使用                           |
| `%mprun`        | 通过逐行的内存分析器运行代码                     |

### 1.9.1 代码段计时: %time和%timeit

`%timeit`可以让代码重复运行来计算代码的运行时间，并且会根据命令的快慢自动调整重复执行的次数。

有时候重复一个操作并不是最佳选择。例如，如果一个列表需要排序，排序一次后列表就已是有序的，对一个有序的列表排序比对一个无序的列表进行排序要快，所以重复运行将使结果出现偏差。对于这种情况，`%time`魔法函数可能是更好的选择：

![%time&%timeit](https://pic4.zhimg.com/80/v2-3b523b7686d16a1a85e9d97dab8c50b5.png)

由于`%timeit`在底层做了一些很聪明的事情来组织系统回调对计时过程的干扰。例如，`%timeit`会阻止清除未利用地Python对象(即**垃圾回收**)，该过程可能影响计时。因此，`%timeit`通常比`%time`更快得到结果。

### 1.9.2 分析整个脚本: %prun

一个程序是由很多单个语句组成的的，有时候对整个脚本计时对比对单个语句计时更重要。`IPython`提供了一种方便的方式来使用分析器，即通过魔法函数`%prun`实现。

结果是一个表格，该表格按照每个函数调用的总时间，显示了哪里的执行时间最长。这这个例子种，大部分执行时间用在`sum_of_list`的列表综合中。**通过观察这个数据，可以帮助了解通过调整哪里来提升算法的性能**。

![%prun](https://pic4.zhimg.com/80/v2-8cebeeeefbfeb10b399a4403b1b45499.png)

### 1.9.3 用`%lprun`进行逐行分析

使用`%lprun`逐行代码分析报告，该功能没有内置于Python和IPython，但是可以通过安装`line_profiler`包来实现。

![%lprun](https://pic4.zhimg.com/80/v2-7c046cfaa9da9adf85fd79b537a866d7.png)

最上面的信息给出了阅读这些结果的关键：报告中的运行时间单位是微秒，可以看到程序中哪些地方最耗时。可以通过这些信息修改代码，使其更高效地实现我们地目的。

### 1.9.4 用`%memit`和`%mprun`进行内存分析

另一种分析是分析一个操作所用地内存量，可以通过IPython的另一个扩展来评估，即`memory_profiler`。和`line_profiler`一样，首先用`pip`安装这个扩展。

内存分析扩展包括两个有用的魔法函数：

- `%memit`提供的内存消耗计算功能类似于`%timeit`
- `mprun`提供的内存消耗计算功能类似于`%lprun`

![%memit](https://pic4.zhimg.com/80/v2-b010b006d9848807eebd71d9fab40119.png)

可以看到这个函数大概消耗了120MB的内存。

对于逐行代码的内存消耗描述，可以用`%mprun`魔法函数。但这个魔法函数仅仅对独立模块内部的函数有效，而对于Notebook本身不起作用，所以首先`%%file`在当前文件夹创建一个简单的模块，将该模块命名为`mprun_demo.py`。它包含`sum_of_list`函数，该函数中包含一次加法，能使内存分析结果更清晰：

| ![%mprun](https://pic4.zhimg.com/80/v2-dbf767cd419bc7c234846aef484cd3df.png)    | ![%mprun](https://pic4.zhimg.com/80/v2-7e4b08c918bf26557dcfcc4bd053cda1.png)    |
| --- | --- |

`Increment`列告诉我们每行代码对总内存预算的影响：创建和删除列表`L`时用掉了149MB的内存。这是除了Python解释器本身外最消耗内存资源的部分。
