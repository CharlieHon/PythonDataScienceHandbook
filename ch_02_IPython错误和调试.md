# IPython：超越Python

## 1.8 错误和调试

### 1.8.1 控制异常: %xmode

大多数时候，当一个Python脚本未执行通过时，会抛出一个异常。当解释器捕获到这些异常时，可以在**轨迹追溯**(traceback)中找到引起这个错误的原因。利用`%xmode`魔法函数，IPython允许你**在异常发生时控制打印信息的数量**。

`%xmode`有一个输入参数，即**模式**。模式有3个可选项：`Plain`, `Context`和`Verbose`。默认情况是 Context。`Plain`更紧凑，给出的信息更少。`Verbose`模式加入了一些额外的信息，包括任何被调用的函数的参数。

|    异常模式                 | 控制异常 |
| ------------------- | -------- |
| `Context`(默认情况) |  ![Image](https://pic4.zhimg.com/80/v2-e436051718a2f95f38d93522d18c3cc5.png)        |
| `Verbose`           |   ![Image](https://pic4.zhimg.com/80/v2-b64dcf45a31c168ee964628d91a4bc99.png)       |
| `Plain`                    |  ![Image](https://pic4.zhimg.com/80/v2-85e998b09772b6eb9fba7a95ce3c0941.png)        |

### 1.8.2. 调试：当阅读轨迹追溯不足以解决问题时

标准的Python交互式调试工具是`pdb`，它是Python的调试器。这个调试器允许用户逐行运行代码，以便查看可能导致错误的原因。IPython增强版的调试器是`ipdb`，它是IPython专用的调试器。

IPython中最方便的调试界面是`%debug`魔法命令。**在捕获异常后调用该调试器，会在异常点自动打开一个交互式调试提示符**。`ipdb`提示符允许探索栈空间的当前状态，探索可用变量，甚至运行Python命令！输入`q(uit)`可以结束调试会话。

![%debug](https://pic4.zhimg.com/80/v2-768333cf4d68902eeae9bc7a6be203f2.png)

可以设置单步入栈和出栈来查看变量的值：

![%debug](https://pic4.zhimg.com/80/v2-7b30e3ebe3560f832586de5f66b4b675.png)

这样可以快速找到导致错误的原因，并且指导是哪一个函数调用导致了错误。
如果希望在发生错误时都自动启动调试器，可以用`%pdb`魔法函数来启动这个自动过程：

![%pdb](https://pic4.zhimg.com/80/v2-b46bac5955ce3d3717d6ce89be23a88a.png)

- **部分调试命令**

以下列举了一部分可用的交互式调试命令及其描述。

| 命令         | 描述                                   |
| ------------ | -------------------------------------- |
| `list`       | 显示文件的当前路径                     |
| `h(help)`    | 显示命令列表，或查找特定命令的帮助信息 |
| `q(uit)`     | 退出调试器和程序                       |
| `c(ontinue)` | 退出调试器，继续运行程序               |
| `n(ext)`     | 调到程序的下一步                       |
| `<enter>`    | 重复前一个命令                         |
| `p(rint)`    | 打印变量                               |
| `s(tep)`     | 步入子进程                             |
| `r(eturn)`   | 从子进程跳出                                       |

在调试器中使用`help`命令，或查看[`ipdb`的在线文档](https://github.com/gotcha/ipdb)获取更多的相关信息。

## 1.9 代码的分析和计时

代码运行后，提高代码的运行效率总是有用的。有时候查看给定命令或一组命令的运行时间非常有用，有时候深入多行进程并确定一系列复杂操作的效率瓶颈也非常有用。IPython提供了很多**执行这些代码计时和分析的操作函数**。

| IPython魔法命令 | 功能                                             |
| --------------- | ------------------------------------------------ |
| `%time`         | 对单个语句的执行时间进行计时                     |
| `%timeit`       | 对单个语句的重复执行进行计时，以获得更高的准确度 |
| `%prun`         | 利用分析器运行代码                               |
| `%lprun`        | 利用逐行分析器运行代码                           |
| `%memit`        | 测量单个语句的内存使用                           |
| `%mprun`        | 通过逐行的内存分析器运行代码                     |

### 1.9.1 代码段计时: %time和%timeit

`%timeit`可以让代码重复运行来计算代码的运行时间，并且会根据命令的快慢自动调整重复执行的次数。

有时候重复一个操作并不是最佳选择。例如，如果一个列表需要排序，排序一次后列表就已是有序的，对一个有序的列表排序比对一个无序的列表进行排序要快，所以重复运行将使结果出现偏差。对于这种情况，`%time`魔法函数可能是更好的选择：

![%time&%timeit](https://pic4.zhimg.com/80/v2-3b523b7686d16a1a85e9d97dab8c50b5.png)

由于`%timeit`在底层做了一些很聪明的事情来组织系统回调对计时过程的干扰。例如，`%timeit`会阻止清除未利用地Python对象(即**垃圾回收**)，该过程可能影响计时。因此，`%timeit`通常比`%time`更快得到结果。

### 1.9.2 分析整个脚本: %prun
